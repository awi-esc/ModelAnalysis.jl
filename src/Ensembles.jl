
module Ensembles

import DataFrames 
import PrettyTables
import CSV

using JLD2
using YAXArrays
using NetCDF
using Statistics

export AbstractEnsemble
export Ensemble
export ensemble_save
export ensemble_sort!
export ensemble_linestyling!
export ensemble_get_var!
export ens_stat
export ensemble_get_var_slice!
export ensemble_check 

abstract type AbstractEnsemble end
abstract type AbstractModelWeights end
abstract type AbstractModelVariables end

mutable struct Ensemble <: AbstractEnsemble 
    path::Vector{String}
    run_path::Vector{String}
    set::Vector{Integer}
    N::Integer
    p::DataFrames.DataFrame             # info/parameters
    s::DataFrames.DataFrame             # styles
    v::Dict{Union{String,Symbol},Any}                    # variables, preferrably YAXArrays or vectors of YAXArrays
    #w::AbstractModelWeights
end

# mutable struct ClimberModelRun
#     path::String
#     p::DataFrames.DataFrame             # info/parameters
#     atm::Dict{Union{String,Symbol},Any}                    # variables, preferrably YAXArrays
#     ocn::Dict{Union{String,Symbol},Any}                    # variables, preferrably YAXArrays
# end

# mutable struct ClimberEnsemble <: AbstractEnsemble
#     path::Vector{String}
#     run_path::Vector{String}
#     set::Vector{Integer}
#     N::Integer
#     p::DataFrames.DataFrame             # info/parameters
#     s::DataFrames.DataFrame             # styles
#     v::Dict{Union{String,Symbol},Any}  # variables, preferrably YAXArrays or vectors of YAXArrays
#     c::Union{Nothing, ClimberModelRun, Vector{ClimberModelRun}}  # new field
# end

function ensemble_init(path::String)   
    
    # Check if path exists
    if !ispath(path)
        error(string("Ensemble::ensemble_init:: Error: path not found: ",path))
    end

    # Define the info filename for an ensemble of simulations
    fname = joinpath(path,"info.txt")

    # Read the ensemble info table into a DataFrame format, if it exists
    if isfile(fname)
        # This is an ensemble, generated by runme. Load the info
        p  = CSV.read(fname,DataFrames.DataFrame,delim=' ',ignorerepeated=true,header=1)
        found_info = true
    else 
        # This is probably a single simulation, so no info file is available.
        # Generate something simple.
        rundir = splitpath(path)[end]
        p = DataFrames.DataFrame("runid"=>1,"rundir"=>rundir)
        found_info = false
    end
    
    # Print parameters/info
    println(p)

    N = DataFrames.nrow(p) 
    
    # Initialize an empty array of the right length
    set = fill(1,N)
    run_path = fill("",N)
    
    # Populate the array
    if found_info
        # Ensemble, populate the run path by combing path with rundir
        for i in 1:N
            run_path[i] = joinpath(path,string(p[i,"rundir"]))
        end
    else
        # Single simulation, set the simulation path equal to the path
        for i in 1:N
            run_path[i] = path
        end
    end

    s = DataFrames.DataFrame()
    s.valid = fill(true,N)
    s.label = fill("",N)
    s.color = fill(colorant"Black",N)
    s.linewidth = fill(1,N)
    s.linestyle = fill(:solid,N)
    s.markersize = fill(1,N) 

    return run_path, set, N, p, s

end

function Ensemble(path::String;sort_by::String="")   
    
    run_path, set, N, p, s = ensemble_init(path)

    # Store all information for output in the ensemble object
    ens = Ensemble([path],run_path,set,N,p,s,Dict())

    if sort_by != ""
        ensemble_sort!(ens,sort_by)
    end
     
    return ens
end

function Ensemble(paths::Array{String};sort_by::String="")   
    
    # Define the ensemble object based on first ensemble set of interest
    ens = Ensemble(paths[1])

    # Define info array for entire list 
    for j = 2:size(paths,1)

        ens_now = Ensemble(paths[j])
        
        ens_now.set .= j 

        if j == 1
            ens = deepcopy(ens_now)
        else
            
            append!(ens.path,ens_now.path)
            append!(ens.run_path,ens_now.run_path)
            append!(ens.set,ens_now.set)
            
            # Handle joining DataFrames using vcat, in case
            # columns are not the same...
            #append!(ens.p,ens_now.p)
            ens.p = vcat(ens.p,ens_now.p; cols=:union)
            ens.s = vcat(ens.s,ens_now.s; cols=:union)
            
        end

    end
    
    # Update the total number of simulations and number of ensemble sets 
    ens.N = DataFrames.nrow(ens.p) 

    println("Loaded ensemble, number of simulations: ",ens.N)
    println("Ensemble path(s):")
    for j = 1:size(paths,1)
        println("  ",paths[j])
    end

    if sort_by != ""
        ensemble_sort!(ens,sort_by)
    end
    
    return ens
end

function ensemble_sort!(ens::AbstractEnsemble,sort_by::String)

    kk = sortperm(ens.p[!,sort_by])
    ens.run_path    = ens.run_path[kk]
    ens.set         = ens.set[kk]
    ens.p           = ens.p[kk,:]
    ens.s           = ens.s[kk,:]

    # Add sorting of each entry of Dictionary v, entries of which should be vectors of length N
    if length(ens.v) != 0
        warning("""Ensemble .v component is not empty, but sorting of v is not yet implemented.
        In this case, the newly sorted ensemble metadata will not match the order of the v entries.
        For now, ensemble sorting should be applied before loading any variables.""")
    end

    return
end

# Save an ensemble to a file using JLD2 but give it a user-defined name for loading later
function ensemble_save(ens::AbstractEnsemble,filename::String,name::String)

    #@save fileout ens
    JLD2.jldopen(filename, "w") do file
        file[name] = ens  # Save the ensemble with the desired name
    end
    println("Saved $filename")

    return
end

function ensemble_linestyling!(ens::AbstractEnsemble;cat_col=nothing,cat_style=nothing,cat_width=nothing,
                                            colors=:tab10,linestyle=:solid,linewidth=1)

    # Set default style options
    ens.s.color     = fill(colorant"Black",ens.N)
    ens.s.linestyle = fill(linestyle,ens.N)
    ens.s.linewidth = fill(linewidth,ens.N)

    if !isnothing(cat_col)
        # Determine unique values of distinguishing variable cat_col
        vals = unique(ens.p[!,cat_col])
    
        # Generate the colormap for these values
        col_map = cgrad(colors,vals);
    
        for (i,val) in enumerate(vals)
            kk = findall(ens.p[!,cat_col] .== val)
            ens.s.color[kk] .= col_map[i]
        end
    
    end

    if !isnothing(cat_style) 
        # Get line styles

        # TO DO

        vals = unique(ens.p[!,cat_style])
    end
    
    if !isnothing(cat_width) 
        # Get line widths

        # TO DO

        vals = unique(ens.p[!,cat_width])
    end

    return
end

function ensemble_get_var(ens::AbstractEnsemble,filename::String,varname::String;newname=nothing,scale=1.0)::Vector{Any}

    println("\nLoad ",varname," from ",filename)
    println("  Ensemble path: ",ens.path)
    println("  Number of simulations: ",size(ens.run_path,1))

    # Get total number of ensemble members 
    N  = ens.N

    # Set how the variable will be saved
    if isnothing(newname) 
        newname = varname
    end

    # Make an empty array to hold the variable 
    vars = []

    # Load time and variable from each simulation in ensemble 
    for k in 1:N 

        # Get path of file of interest for reference sim
        path_now = joinpath(ens.run_path[k],filename)

        # Open NetCDF file as a set of YAXArrays
        ds = open_dataset(path_now,driver=:netcdf)

        # Get variable if it is available
        if !haskey(ds, varname)
            close(ds)
            error("load_var:: Error: variable $(varname) not found in file:\n    $(path_now)")
        end

        # Read a YAXArray, but load it into memory (not lazy)
        var = readcubedata(ds[varname])

        # Close NetCDF file
        #close(ds) 

        # Scale variable as desired 
        var .= var .* scale

        # Store variable in output array
        push!(vars, var)

    end

    # Return a vector of variables of length of ensemble
    return vars
end

function ensemble_get_var!(ens::AbstractEnsemble,filename::String,varname::String;newname=nothing,scale=1.0)

    # Load the vector of ensemble data
    vars = ensemble_get_var(ens,filename,varname;newname)
    
    # Store in ensemble struct
    ens.v[newname] = vars

    return
end

function ens_stat(var::Vector{Any},stat::Function)

    vals = fill(NaN,ens.N)

    for j = 1:ens.N
        vals[j] = stat(var[j])
    end

    return vals
end

function ensemble_get_var_slice!(ens::AbstractEnsemble,vout::String,vin::String;time_slice=nothing,
                                 var_dim=nothing)
    # TODO: Adjust for using YAXArrays with a time dimension!!

    # Get number of ensemble members
    N = size(ens.p,1);

    # Generate output variable
    var_out = fill(NaN,N);

    # Get variable for each ensemble member
    for k = 1:N

        # Load variable from ensemble object 
        time = ens.v["time"][k]
        var  = ens.v[vin][k] 

        # Get time index of interest
        if isnothing(time_slice)
            time_now = maximum(time)
        else
            time_now = time_slice 
        end 

        tmp = findmin(abs.(time .- time_now))
        nt  = tmp[2]
        
        # Populate output variable
        var_out[k] = var[nt];

    end 

    if isnothing(var_dim)
        out = var_out 
    else 
        out = [var_dim var_out]
    end

    ens.v[vout] = out 

    return

end

#### Functions related to testing specific things 

function ensemble_check(path::String; vars = nothing)

    # Load ensemble information
    ens = Ensemble(path);

    # Initially only loading standard PD comparison statistics variables
    var_names = ["time","rmse_H","rmse_zsrf","rmse_uxy","rmse_uxy_log"];

    # Add any other variables of interest from arguments
    if vars != nothing
        push!(var_names,vars);
    end 

    # Loop over all variable names of interest
    # (should be 1D time series, for now!)
    for vname in var_names
        ensemble_get_var!(ens,"yelmo2D.nc",vname);
    end

    # Generate a dataframe to hold output information in pretty format 
    df = DataFrames.DataFrame(runid = ens.p[!,:runid]);

    for vname in var_names
        #print(vname,size(ens.v[vname]),"\n")
        if ndims(ens.v[vname]) == 1
            v = [ens.v[vname][i][end] for i in 1:length(ens.v[vname])];
            DataFrames.insertcols!(df, vname => v )
        else
            print("ensemble_check:: Error: this function should be used with time series variables")
            print("vname = ", vname)
            return
        end
    end

    # Print information to screen, first about
    # ensemble (info) and then variables of interest.

    PrettyTables.pretty_table(ens.p, header = names(ens.p), crop = :horizontal)
    PrettyTables.pretty_table(df, header = names(df), crop = :horizontal)

    return ens
end

end # module